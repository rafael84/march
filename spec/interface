# vim:ft=Marchfile
module user

#   type UserAPI struct {}
UserAPI interface {

#   func (i *UserAPI) renderJSON(w http.ResponseWriter, status int, data interface{}) {
#       ctx, logger := cid.Track(r.Context(), tag)
#       w.Header().Set("Content-Type", "application/json; charset=UTF-8")
#       w.WriteHeader(status)
#       if err := json.NewEncoder(w).Encode(data); err != nil {
#           logger.E("unexpected error", "err", err)
#       }
#   }

#   func (i *UserAPI) GetUser(w http.ResponseWriter, r *http.Request) {
#       ctx, logger := cid.Track(r.Context(), tag)
    GET "/user" {

#       users, err := UserService.List(ctx)
#       if err != nil {
#           logger.W("list from user service failed", "err", err)
#           i.renderJSON(w, http.StatusInternalServerError, CouldNotListUser.WithDetail(err))
#           return
#       }
        get users from UserService List \
            or halt with INTERNAL_SERVER_ERROR and CouldNotListUser

#       i.renderJSON(w, http.StatusOK, users)
#       return
        return OK and users
    }

#   func (i *UserAPI) PostUser(w http.ResponseWriter, r *http.Request) {
#       ctx, logger := cid.Track(r.Context(), tag)
    POST "/user" {

#       user := new(UserCreateRequest)
#       if err := json.UnMarshal(r.Body, user); err != nil {
#           logger.W("decode request body as user create request failed", "err", err)
#           i.renderJSON(w, http.StatusBadRequest, InvalidUserCreateRequest.WithDetail(err))
#           return
#       }
        get user from decode REQUEST BODY as UserCreateRequest \
            or halt with BAD_REQUEST and InvalidUserCreateRequest

#       newUser, err := UserService.Create(ctx, user)
#       if err != nil {
#           switch err {
#           case UserCreateRequestValidationFailed:
#               logger.W("create from user service failed", "err", err)
#               i.renderJSON(w, http.StatusBadRequest, CouldNotCreateUser.WithDetail(err))
#               return
#           default:
#               logger.W("create from user service failed", "err", err)
#               i.renderJSON(w, http.StatusInternalServerError, CouldNotCreateUser.WithDetail(err))
#               return
#           }
#       }
        get newUser from UserService Create with user {
            when UserCreateRequestValidationFailed {
                return BAD_REQUEST and FAILURE
            }
            when FAILURE {
                return INTERNAL_SERVER_ERROR and CouldNotCreateUser
            }
        }

#       i.renderJSON(w, http.StatusCreated, newUser)
#       return
        return CREATED and newUser
    }


#   func (i *UserAPI) GetUserByID(w http.ResponseWriter, r *http.Request) {
#       ctx, logger := cid.Track(r.Context(), tag)
    GET "/user/:id" {

#       var userID int64
#       if parsed, err := strconv.ParseInt(mux.Vars(r)["id"], 10, 64); err != nil {
#           logger.W("decode path id as int failed", "err", err)
#           i.renderJSON(w, http.StatusBadRequest, InvalidUserID.WithDetail(err))
#           return
#       }
        get userID from decode PATH id as int \
            or halt with BAD_REQUEST and InvalidUserID

#       user, err := UserService.Lookup(ctx, userID)
#       if err != nil {
#           logger.W("lookup from user service failed", "err", err)
#           i.renderJSON(w, http.StatusInternalServerError, CouldNotListUser.WithDetail(err))
#           return
#       }
        get user from UserService Lookup with userID \
            or halt with INTERNAL_SERVER_ERROR and CouldNotListUser

#       i.renderJSON(w, http.StatusOK, user)
#       return
        return OK and user
    }


#   func (i *UserAPI) PutUserByID(w http.ResponseWriter, r *http.Request) {
#       ctx, logger := cid.Track(r.Context(), tag)
    PUT "/user/:id" {

#       var userID int64
#       if parsed, err := strconv.ParseInt(mux.Vars(r)["id"], 10, 64); err != nil {
#           logger.W("decode path id as int failed", "err", err)
#           i.renderJSON(w, http.StatusBadRequest, InvalidUserID.WithDetail(err))
#           return
#       }
        get userID from decode PATH id as int \
            or halt with BAD_REQUEST and InvalidUserID

#       request := new(UserUpdateRequest)
#       if err := json.UnMarshal(r.Body, request); err != nil {
#           logger.W("decode request body as user update request failed", "err", err)
#           i.renderJSON(w, http.StatusBadRequest, InvalidUserUpdateRequest.WithDetail(err))
#           return
#       }
        get request from decode REQUEST BODY as UserUpdateRequest \
            or halt with BAD_REQUEST and InvalidUserUpdateRequest

#       user, err := UserService.Update(ctx, userID, request)
#       if err != nil {
#           switch err {
#           case UserNotFound:
#               logger.W("update from user service failed", "err", err)
#               i.renderJSON(w, http.StatusNotFound, CouldNotUpdateUser.WithDetail(err))
#               return
#           default:
#               logger.W("update from user service failed", "err", err)
#               i.renderJSON(w, http.StatusInternalServerError, CouldNotUpdateUser.WithDetail(err))
#               return
#           }
#       }
        get user from UserService Update with userID and request {
            when UserNotFound {
                return NOT_FOUND and UserNotFound
            }
            when FAILURE {
                return INTERNAL_SERVER_ERROR and CouldNotUpdateUser
            }
        }

#       i.renderJSON(w, http.StatusOK, user)
#       return
        return OK and user
    }
}
