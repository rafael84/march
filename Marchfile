import "config"

config {
    Log {
        Level string -- default info
    }
    Address string -- default :8080
    Database {
        URL string -- default pg://user:pass@127.0.0.1/users?sslmode=disabled
    }
    Workers {
        Queue {
            Size int -- default 100 minimum 1 maximum 200
        }
    }
    UpdateInterval interval
}


domain UserAddress {
    Phone string
    Address string
}

domain UserMetadata {
    LastLogin timestamp
}

domain User {
    ID int -- identity
    Name string
    Email string -- validate
    Login string -- validate regex:[a-zA-Z0-9]
    Password hash -- hidden
    IsAdmin bool
    Address UserAddress
    Metadata UserMetadata -- optional
    GroupID int -- foreign Group
    Groups []Group -- fetch LAZY
}

domain UserCreateRequest {
    Name    @User.Name
    Email   @User.Email
    Login   @User.Login
    Phone   @Address.Phone
    Address @Address.Address
}

domain UserUpdateRequest {
    Name    @User.Name
    Email   @User.Email
    Phone   @Address.Phone
    Address @Address.Address
}

domain Group {
    ID int -- identity
    Name string
}


# implies a CRUD like repository for domain User
repository UserRepository for User {
    option "table" is "auth.user"
}


# implies a CRUD like repository for domain Group
repository GroupRepository for Group {

}

error 1000 {
    CouldNotListUsers        # implies ID=1000, Message=could not list users
    InvalidUserCreateRequest # implies ID=1001, Message=invalid user create request
    InvalidUserID            # implies ID=1002, Message=invalid user id
}

error 2000 {
    CouldNotCreateUser # implies ID=2000, Message=could not create user
    UserNotFound
}

error 3000 {
    CouldNotLoadUsersFromRepository   # implies ID=3000, Message=could not load users from repository
    UserCreateRequestValidationFailed
    CouldNotCreateUser
    UserUpdateRequestValidationFailed
    CouldNotUpdateUser
}


service UserService {

# implies:
#
# func (s *UserService) List(ctx context.Context) ([]*User, error) {
#   ctx, logger := cid.Track(ctx, tag)
#   users, err := repository.Of(&User{}).List(ctx)
#   if err != nil {
#       logger.W(CouldNotLoadUsersFromRepository.Message, "err", err)
#       return nil, CouldNotLoadUsersFromRepository.WithDetail(err)
#   }
#   return users, nil
# }
    method List returns []User {
        from UserRepository do List returning users {
            on FAILURE {
                return CouldNotLoadUsersFromRepository
            }
        }
        return users
    }

#   implies:
#
#   func (s *UserService) Create(ctx context.Context, req *UserCreateRequestValidationFailed) (*User, error) {
#       ctx, logger := cid.Track(ctx, tag)
#       if err := req.Validate(ctx); err != nil {
#           logger.W(UserCreateRequestValidationFailed.Message, "err", err)
#           return nil, UserCreateRequestValidationFailed.WithDetail(err)
#       }
#       user, err := repository.Of(&User{}).Create(ctx, req)
#       if err != nil {
#           logger.W(CouldNotCreateUser.Message, "err", err)
#           return nil, CouldNotCreateUser.WithDetail(err)
#       }
#       return users, nil
#   }
    method Create with req as UserCreateRequest returns User {
        from req do Validate {
            on FAILURE {
                return UserCreateRequestValidationFailed
            }
        }
        from UserRepository do Create with req returning user {
            on FAILURE {
                return CouldNotCreateUser
            }
        }
        return user
    }

    method Update with userID as int and req as UserUpdateRequest returns User {
        from req do Validate {
            on FAILURE {
                return UserUpdateRequestValidationFailed
            }
        }
        from UserRepository do Lookup with userID returning user {
            on FAILURE {
                return UserNotFound
            }
        }
        from UserRepository do Update with req returning user {
            on FAILURE {
                return CouldNotUpdateUser
            }
        }
        return user
    }

    method Lookup with id as int returns []User {

    }

    method SearchByName with name as string returns []User {

    }

    method SearchByEmail with email as string returns []User {

    }

    method SearchAdmins returns []User {

    }
}

interface UserInterface {
    GET "/user" {
        from UserService do List returning users {
            on FAILURE {
                render INTERNAL_SERVER_ERROR and CouldNotListUser
            }
        }
        render OK and users
    }

    POST "/user" {
        from REQUEST decode BODY as UserCreateRequest returning user {
            on FAILURE {
                render BAD_REQUEST and InvalidUserCreateRequest
            }
        }
        from UserService do Create with user returning newUser {
            on FAILURE {
                render INTERNAL_SERVER_ERROR and CouldNotListUser
            }
        }
        render CREATED and newUser
    }

    GET "/user/:id" {
        from REQUEST_PATH decode id as int returning userID {
            on FAILURE {
                render BAD_REQUEST and InvalidUserID
            }
        }
        from UserService do Lookup with userID returning user {
            on FAILURE {
                render INTERNAL_SERVER_ERROR and CouldNotListUser
            }
        }
        render OK and user
    }

    PUT "/user/:id" {
        from REQUEST_PATH decode id as int returning userID {
            on FAILURE {
                render BAD_REQUEST and InvalidUserID
            }
        }
        from REQUEST decode BODY as UserUpdateRequest returning req {
            on FAILURE {
                render BAD_REQUEST and InvalidUserCreateRequest
            }
        }
        from UserService do Update with id and req returning user {
            on UserNotFound {
                render NOT_FOUND and UserNotFound
            }
            on FAILURE {
                render INTERNAL_SERVER_ERROR and CouldNotUpdateUser
            }
        }
        render OK and user
    }
}
