import "repository"

config {
    Log {
        Level string -- default info
    }
    Address string -- default :8080
    Database {
        URL string -- default pg://user:pass@127.0.0.1/users?sslmode=disabled
    }
}

config UpdateInterval interval

config Workers {
    Queue {
        Size int -- default 100 minimum 1 maximum 200
    }
}

domain User {
    ID int -- identity
    Name string
    Email string -- validate
    Login string -- validate regex:[a-zA-Z0-9]
    Password hash -- hidden
    IsAdmin bool
    Address {
        Phone string
        Address string
    }
    Metadata {
        LastLogin timestamp -- optional
    }
    Groups [1:*]Group
}

domain UserCreateRequest {
    Name    @User.Name
    Email   @User.Email
    Login   @User.Login
    Phone   @User.Address.Phone
    Address @User.Address.Address
}

domain Group {
    ID int -- identity
    Name string
}

error 1000 {
    CouldNotListUsers        # implies ID=1000, Message=could not list users
    InvalidUserCreateRequest # implies ID=1001, Message=invalid user create request
    InvalidUserID            # implies ID=1002, Message=invalid user id
}

error 2000 {
    CouldNotCreateUser # implies ID=2000, Message=could not create user
}

error 3000 {
    CouldNotLoadUsersFromRepository   # implies ID=3000, Message=could not load users from repository
    UserCreateRequestValidationFailed # implies ID=3001, Message=user create request validation failed
    CouldNotCreateUser
}

service UserService {

# implies:
#
# func (s *UserService) List(ctx context.Context) ([]*User, error) {
#   users, err := repository.Of(&User{}).List(ctx)
#   if err != nil {
#       return nil, CouldNotLoadUsersFromRepository.WithDetail(err)
#   }
#   return users, nil
# }
    method List returns []User {
        from repository call ListUser into users {
            on FAILURE {
                return CouldNotLoadUsersFromRepository
            }
            on SUCCESS {
                return users
            }
        }
    }

# implies:
#
# func (s *UserService) Create(ctx context.Context, req *UserCreateRequestValidationFailed) (*User, error) {
#   if err := req.Validate(ctx); err != nil {
#       return nil, UserCreateRequestValidationFailed.WithDetail(err)
#   }
#   user, err := repository.Of(&User{}).Create(ctx, req)
#   if err != nil {
#       return nil, CouldNotCreateUser.WithDetail(err)
#   }
#   return users, nil
# }
    method Create with req as UserCreateRequest returns User {
        from req call Validate {
            on FAILURE {
                return UserCreateRequestValidationFailed
            }
            on SUCCESS {
                from repository call CreateUser with req into user {
                    on FAILURE {
                        return CouldNotCreateUser
                    }
                    on SUCCESS {
                        return user
                    }
                }
            }
        }
    }

    method Update with req as UserUpdateRequest returns User {

    }

    method Lookup with id as int returns []User {

    }

    method SearchByName with name as string returns []User {

    }

    method SearchByEmail with email as string returns []User {

    }

    method SearchAdmins returns []User {

    }
}

interface UserInterface {
    GET "/user" {
        from UserService call List into users {
            on FAILURE {
                render INTERNAL_SERVER_ERROR, CouldNotListUser
            }
            on SUCCESS {
                render OK, users
            }
        }
    }

    POST "/user" {
        from REQUEST decode BODY as UserCreateRequest into user {
            on FAILURE {
                render BAD_REQUEST, InvalidUserCreateRequest
            }
            on SUCCESS {
                from UserService call Create with user into newUser {
                    on FAILURE {
                        render INTERNAL_SERVER_ERROR, CouldNotListUser
                    }
                    on SUCCESS {
                        render CREATED, newUser
                    }
                }
            }
        }
    }

    GET "/user/:id" {
        from REQUEST_PATH decode id as int into userID {
            on FAILURE {
                render BAD_REQUEST, InvalidUserID
            }
            on SUCCESS {
                from UserService call Lookup with userID into user {
                    on FAILURE {
                        render INTERNAL_SERVER_ERROR, CouldNotListUser
                    }
                    on SUCCESS {
                        render OK, user
                    }
                }
            }
        }
    }
}
